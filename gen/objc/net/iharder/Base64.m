//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/marcussmith/temp/base64/src/net/iharder/Base64.java
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/io/BufferedInputStream.h"
#include "java/io/BufferedOutputStream.h"
#include "java/io/ByteArrayInputStream.h"
#include "java/io/ByteArrayOutputStream.h"
#include "java/io/File.h"
#include "java/io/FileInputStream.h"
#include "java/io/FileOutputStream.h"
#include "java/io/FilterInputStream.h"
#include "java/io/FilterOutputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/io/ObjectInputStream.h"
#include "java/io/ObjectOutputStream.h"
#include "java/io/OutputStream.h"
#include "java/io/Serializable.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/Byte.h"
#include "java/lang/ClassNotFoundException.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/System.h"
#include "java/nio/ByteBuffer.h"
#include "java/nio/CharBuffer.h"
#include "java/util/zip/GZIPInputStream.h"
#include "java/util/zip/GZIPOutputStream.h"
#include "net/iharder/Base64.h"

/*!
 @brief Maximum line length (76) of Base64 output.
 */
inline jint NetIharderBase64_get_MAX_LINE_LENGTH(void);
#define NetIharderBase64_MAX_LINE_LENGTH 76
J2OBJC_STATIC_FIELD_CONSTANT(NetIharderBase64, MAX_LINE_LENGTH, jint)

/*!
 @brief The equals sign (=) as a byte.
 */
inline jbyte NetIharderBase64_get_EQUALS_SIGN(void);
#define NetIharderBase64_EQUALS_SIGN 61
J2OBJC_STATIC_FIELD_CONSTANT(NetIharderBase64, EQUALS_SIGN, jbyte)

/*!
 @brief The new line character (\n) as a byte.
 */
inline jbyte NetIharderBase64_get_NEW_LINE(void);
#define NetIharderBase64_NEW_LINE 10
J2OBJC_STATIC_FIELD_CONSTANT(NetIharderBase64, NEW_LINE, jbyte)

/*!
 @brief Preferred encoding.
 */
inline NSString *NetIharderBase64_get_PREFERRED_ENCODING(void);
static NSString *NetIharderBase64_PREFERRED_ENCODING = @"US-ASCII";
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetIharderBase64, PREFERRED_ENCODING, NSString *)

inline jbyte NetIharderBase64_get_WHITE_SPACE_ENC(void);
#define NetIharderBase64_WHITE_SPACE_ENC -5
J2OBJC_STATIC_FIELD_CONSTANT(NetIharderBase64, WHITE_SPACE_ENC, jbyte)

inline jbyte NetIharderBase64_get_EQUALS_SIGN_ENC(void);
#define NetIharderBase64_EQUALS_SIGN_ENC -1
J2OBJC_STATIC_FIELD_CONSTANT(NetIharderBase64, EQUALS_SIGN_ENC, jbyte)

/*!
 @brief The 64 valid Base64 values.
 */
inline IOSByteArray *NetIharderBase64_get__STANDARD_ALPHABET(void);
static IOSByteArray *NetIharderBase64__STANDARD_ALPHABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetIharderBase64, _STANDARD_ALPHABET, IOSByteArray *)

/*!
 @brief Translates a Base64 value to either its 6-bit reconstruction value
  or a negative number indicating some other meaning.
 */
inline IOSByteArray *NetIharderBase64_get__STANDARD_DECODABET(void);
static IOSByteArray *NetIharderBase64__STANDARD_DECODABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetIharderBase64, _STANDARD_DECODABET, IOSByteArray *)

/*!
 @brief Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548:  
 <a href="http://www.faqs.org/rfcs/rfc3548.html">http://www.faqs.org/rfcs/rfc3548.html</a>.
 Notice that the last two bytes become "hyphen" and "underscore" instead of "plus" and "slash."
 */
inline IOSByteArray *NetIharderBase64_get__URL_SAFE_ALPHABET(void);
static IOSByteArray *NetIharderBase64__URL_SAFE_ALPHABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetIharderBase64, _URL_SAFE_ALPHABET, IOSByteArray *)

/*!
 @brief Used in decoding URL- and Filename-safe dialects of Base64.
 */
inline IOSByteArray *NetIharderBase64_get__URL_SAFE_DECODABET(void);
static IOSByteArray *NetIharderBase64__URL_SAFE_DECODABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetIharderBase64, _URL_SAFE_DECODABET, IOSByteArray *)

/*!
 @brief I don't get the point of this technique, but someone requested it,
  and it is described here: 
 <a href="http://www.faqs.org/qa/rfcc-1940.html">http://www.faqs.org/qa/rfcc-1940.html</a>.
 */
inline IOSByteArray *NetIharderBase64_get__ORDERED_ALPHABET(void);
static IOSByteArray *NetIharderBase64__ORDERED_ALPHABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetIharderBase64, _ORDERED_ALPHABET, IOSByteArray *)

/*!
 @brief Used in decoding the "ordered" dialect of Base64.
 */
inline IOSByteArray *NetIharderBase64_get__ORDERED_DECODABET(void);
static IOSByteArray *NetIharderBase64__ORDERED_DECODABET;
J2OBJC_STATIC_FIELD_OBJ_FINAL(NetIharderBase64, _ORDERED_DECODABET, IOSByteArray *)

__attribute__((unused)) static IOSByteArray *NetIharderBase64_getAlphabetWithInt_(jint options);

__attribute__((unused)) static IOSByteArray *NetIharderBase64_getDecodabetWithInt_(jint options);

__attribute__((unused)) static void NetIharderBase64_init(NetIharderBase64 *self);

__attribute__((unused)) static NetIharderBase64 *new_NetIharderBase64_init(void) NS_RETURNS_RETAINED;

__attribute__((unused)) static NetIharderBase64 *create_NetIharderBase64_init(void);

__attribute__((unused)) static IOSByteArray *NetIharderBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(IOSByteArray *b4, IOSByteArray *threeBytes, jint numSigBytes, jint options);

__attribute__((unused)) static IOSByteArray *NetIharderBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, jint numSigBytes, IOSByteArray *destination, jint destOffset, jint options);

__attribute__((unused)) static jint NetIharderBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, IOSByteArray *destination, jint destOffset, jint options);

@interface NetIharderBase64_InputStream () {
 @public
  jboolean encode_;
  jint position_;
  IOSByteArray *buffer_;
  jint bufferLength_;
  jint numSigBytes_;
  jint lineLength_;
  jboolean breakLines_;
  jint options_;
  IOSByteArray *alphabet_;
  IOSByteArray *decodabet_;
}

@end

J2OBJC_FIELD_SETTER(NetIharderBase64_InputStream, buffer_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetIharderBase64_InputStream, alphabet_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetIharderBase64_InputStream, decodabet_, IOSByteArray *)

@interface NetIharderBase64_OutputStream () {
 @public
  jboolean encode_;
  jint position_;
  IOSByteArray *buffer_;
  jint bufferLength_;
  jint lineLength_;
  jboolean breakLines_;
  IOSByteArray *b4_;
  jboolean suspendEncoding_;
  jint options_;
  IOSByteArray *alphabet_;
  IOSByteArray *decodabet_;
}

@end

J2OBJC_FIELD_SETTER(NetIharderBase64_OutputStream, buffer_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetIharderBase64_OutputStream, b4_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetIharderBase64_OutputStream, alphabet_, IOSByteArray *)
J2OBJC_FIELD_SETTER(NetIharderBase64_OutputStream, decodabet_, IOSByteArray *)

J2OBJC_INITIALIZED_DEFN(NetIharderBase64)

@implementation NetIharderBase64

+ (void)encodeWithJavaNioByteBuffer:(JavaNioByteBuffer *)raw
              withJavaNioByteBuffer:(JavaNioByteBuffer *)encoded {
  NetIharderBase64_encodeWithJavaNioByteBuffer_withJavaNioByteBuffer_(raw, encoded);
}

+ (void)encodeWithJavaNioByteBuffer:(JavaNioByteBuffer *)raw
              withJavaNioCharBuffer:(JavaNioCharBuffer *)encoded {
  NetIharderBase64_encodeWithJavaNioByteBuffer_withJavaNioCharBuffer_(raw, encoded);
}

+ (NSString *)encodeObjectWithJavaIoSerializable:(id<JavaIoSerializable>)serializableObject {
  return NetIharderBase64_encodeObjectWithJavaIoSerializable_(serializableObject);
}

+ (NSString *)encodeObjectWithJavaIoSerializable:(id<JavaIoSerializable>)serializableObject
                                         withInt:(jint)options {
  return NetIharderBase64_encodeObjectWithJavaIoSerializable_withInt_(serializableObject, options);
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source {
  return NetIharderBase64_encodeBytesWithByteArray_(source);
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(jint)options {
  return NetIharderBase64_encodeBytesWithByteArray_withInt_(source, options);
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(jint)off
                               withInt:(jint)len {
  return NetIharderBase64_encodeBytesWithByteArray_withInt_withInt_(source, off, len);
}

+ (NSString *)encodeBytesWithByteArray:(IOSByteArray *)source
                               withInt:(jint)off
                               withInt:(jint)len
                               withInt:(jint)options {
  return NetIharderBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(source, off, len, options);
}

+ (IOSByteArray *)encodeBytesToBytesWithByteArray:(IOSByteArray *)source {
  return NetIharderBase64_encodeBytesToBytesWithByteArray_(source);
}

+ (IOSByteArray *)encodeBytesToBytesWithByteArray:(IOSByteArray *)source
                                          withInt:(jint)off
                                          withInt:(jint)len
                                          withInt:(jint)options {
  return NetIharderBase64_encodeBytesToBytesWithByteArray_withInt_withInt_withInt_(source, off, len, options);
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)source {
  return NetIharderBase64_decodeWithByteArray_(source);
}

+ (IOSByteArray *)decodeWithByteArray:(IOSByteArray *)source
                              withInt:(jint)off
                              withInt:(jint)len
                              withInt:(jint)options {
  return NetIharderBase64_decodeWithByteArray_withInt_withInt_withInt_(source, off, len, options);
}

+ (IOSByteArray *)decodeWithNSString:(NSString *)s {
  return NetIharderBase64_decodeWithNSString_(s);
}

+ (IOSByteArray *)decodeWithNSString:(NSString *)s
                             withInt:(jint)options {
  return NetIharderBase64_decodeWithNSString_withInt_(s, options);
}

+ (id)decodeToObjectWithNSString:(NSString *)encodedObject {
  return NetIharderBase64_decodeToObjectWithNSString_(encodedObject);
}

+ (void)encodeToFileWithByteArray:(IOSByteArray *)dataToEncode
                     withNSString:(NSString *)filename {
  NetIharderBase64_encodeToFileWithByteArray_withNSString_(dataToEncode, filename);
}

+ (void)decodeToFileWithNSString:(NSString *)dataToDecode
                    withNSString:(NSString *)filename {
  NetIharderBase64_decodeToFileWithNSString_withNSString_(dataToDecode, filename);
}

+ (IOSByteArray *)decodeFromFileWithNSString:(NSString *)filename {
  return NetIharderBase64_decodeFromFileWithNSString_(filename);
}

+ (NSString *)encodeFromFileWithNSString:(NSString *)filename {
  return NetIharderBase64_encodeFromFileWithNSString_(filename);
}

+ (void)encodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile {
  NetIharderBase64_encodeFileToFileWithNSString_withNSString_(infile, outfile);
}

+ (void)decodeFileToFileWithNSString:(NSString *)infile
                        withNSString:(NSString *)outfile {
  NetIharderBase64_decodeFileToFileWithNSString_withNSString_(infile, outfile);
}

+ (void)initialize {
  if (self == [NetIharderBase64 class]) {
    JreStrongAssignAndConsume(&NetIharderBase64__STANDARD_ALPHABET, [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G', (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N', (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U', (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g', (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n', (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u', (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z', (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) '+', (jbyte) '/' } count:64]);
    JreStrongAssignAndConsume(&NetIharderBase64__STANDARD_DECODABET, [IOSByteArray newArrayWithBytes:(jbyte[]){ -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 62, -9, -9, -9, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -9, -9, -9, -1, -9, -9, -9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -9, -9, -9, -9, -9, -9, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -9, -9, -9, -9 } count:127]);
    JreStrongAssignAndConsume(&NetIharderBase64__URL_SAFE_ALPHABET, [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G', (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N', (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U', (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g', (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n', (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u', (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z', (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) '-', (jbyte) '_' } count:64]);
    JreStrongAssignAndConsume(&NetIharderBase64__URL_SAFE_DECODABET, [IOSByteArray newArrayWithBytes:(jbyte[]){ -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 62, -9, -9, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -9, -9, -9, -1, -9, -9, -9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -9, -9, -9, -9, 63, -9, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -9, -9, -9, -9 } count:127]);
    JreStrongAssignAndConsume(&NetIharderBase64__ORDERED_ALPHABET, [IOSByteArray newArrayWithBytes:(jbyte[]){ (jbyte) '-', (jbyte) '0', (jbyte) '1', (jbyte) '2', (jbyte) '3', (jbyte) '4', (jbyte) '5', (jbyte) '6', (jbyte) '7', (jbyte) '8', (jbyte) '9', (jbyte) 'A', (jbyte) 'B', (jbyte) 'C', (jbyte) 'D', (jbyte) 'E', (jbyte) 'F', (jbyte) 'G', (jbyte) 'H', (jbyte) 'I', (jbyte) 'J', (jbyte) 'K', (jbyte) 'L', (jbyte) 'M', (jbyte) 'N', (jbyte) 'O', (jbyte) 'P', (jbyte) 'Q', (jbyte) 'R', (jbyte) 'S', (jbyte) 'T', (jbyte) 'U', (jbyte) 'V', (jbyte) 'W', (jbyte) 'X', (jbyte) 'Y', (jbyte) 'Z', (jbyte) '_', (jbyte) 'a', (jbyte) 'b', (jbyte) 'c', (jbyte) 'd', (jbyte) 'e', (jbyte) 'f', (jbyte) 'g', (jbyte) 'h', (jbyte) 'i', (jbyte) 'j', (jbyte) 'k', (jbyte) 'l', (jbyte) 'm', (jbyte) 'n', (jbyte) 'o', (jbyte) 'p', (jbyte) 'q', (jbyte) 'r', (jbyte) 's', (jbyte) 't', (jbyte) 'u', (jbyte) 'v', (jbyte) 'w', (jbyte) 'x', (jbyte) 'y', (jbyte) 'z' } count:64]);
    JreStrongAssignAndConsume(&NetIharderBase64__ORDERED_DECODABET, [IOSByteArray newArrayWithBytes:(jbyte[]){ -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -5, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -5, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, 0, -9, -9, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -9, -9, -9, -1, -9, -9, -9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, -9, -9, -9, -9, 37, -9, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, -9, -9, -9, -9 } count:127]);
    J2OBJC_SET_INITIALIZED(NetIharderBase64)
  }
}

@end

IOSByteArray *NetIharderBase64_getAlphabetWithInt_(jint options) {
  NetIharderBase64_initialize();
  if ((options & NetIharderBase64_URL_SAFE) == NetIharderBase64_URL_SAFE) {
    return NetIharderBase64__URL_SAFE_ALPHABET;
  }
  else if ((options & NetIharderBase64_ORDERED) == NetIharderBase64_ORDERED) {
    return NetIharderBase64__ORDERED_ALPHABET;
  }
  else {
    return NetIharderBase64__STANDARD_ALPHABET;
  }
}

IOSByteArray *NetIharderBase64_getDecodabetWithInt_(jint options) {
  NetIharderBase64_initialize();
  if ((options & NetIharderBase64_URL_SAFE) == NetIharderBase64_URL_SAFE) {
    return NetIharderBase64__URL_SAFE_DECODABET;
  }
  else if ((options & NetIharderBase64_ORDERED) == NetIharderBase64_ORDERED) {
    return NetIharderBase64__ORDERED_DECODABET;
  }
  else {
    return NetIharderBase64__STANDARD_DECODABET;
  }
}

void NetIharderBase64_init(NetIharderBase64 *self) {
  NSObject_init(self);
}

NetIharderBase64 *new_NetIharderBase64_init() {
  J2OBJC_NEW_IMPL(NetIharderBase64, init)
}

NetIharderBase64 *create_NetIharderBase64_init() {
  J2OBJC_CREATE_IMPL(NetIharderBase64, init)
}

IOSByteArray *NetIharderBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(IOSByteArray *b4, IOSByteArray *threeBytes, jint numSigBytes, jint options) {
  NetIharderBase64_initialize();
  NetIharderBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(threeBytes, 0, numSigBytes, b4, 0, options);
  return b4;
}

IOSByteArray *NetIharderBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, jint numSigBytes, IOSByteArray *destination, jint destOffset, jint options) {
  NetIharderBase64_initialize();
  IOSByteArray *ALPHABET = NetIharderBase64_getAlphabetWithInt_(options);
  jint inBuff = (numSigBytes > 0 ? (JreURShift32((JreLShift32(IOSByteArray_Get(nil_chk(source), srcOffset), 24)), 8)) : 0) | (numSigBytes > 1 ? (JreURShift32((JreLShift32(IOSByteArray_Get(nil_chk(source), srcOffset + 1), 24)), 16)) : 0) | (numSigBytes > 2 ? (JreURShift32((JreLShift32(IOSByteArray_Get(nil_chk(source), srcOffset + 2), 24)), 24)) : 0);
  switch (numSigBytes) {
    case 3:
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = IOSByteArray_Get(nil_chk(ALPHABET), (JreURShift32(inBuff, 18)));
    *IOSByteArray_GetRef(destination, destOffset + 1) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 12)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 2) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 6)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 3) = IOSByteArray_Get(ALPHABET, (inBuff) & (jint) 0x3f);
    return destination;
    case 2:
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = IOSByteArray_Get(nil_chk(ALPHABET), (JreURShift32(inBuff, 18)));
    *IOSByteArray_GetRef(destination, destOffset + 1) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 12)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 2) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 6)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 3) = NetIharderBase64_EQUALS_SIGN;
    return destination;
    case 1:
    *IOSByteArray_GetRef(nil_chk(destination), destOffset) = IOSByteArray_Get(nil_chk(ALPHABET), (JreURShift32(inBuff, 18)));
    *IOSByteArray_GetRef(destination, destOffset + 1) = IOSByteArray_Get(ALPHABET, (JreURShift32(inBuff, 12)) & (jint) 0x3f);
    *IOSByteArray_GetRef(destination, destOffset + 2) = NetIharderBase64_EQUALS_SIGN;
    *IOSByteArray_GetRef(destination, destOffset + 3) = NetIharderBase64_EQUALS_SIGN;
    return destination;
    default:
    return destination;
  }
}

void NetIharderBase64_encodeWithJavaNioByteBuffer_withJavaNioByteBuffer_(JavaNioByteBuffer *raw, JavaNioByteBuffer *encoded) {
  NetIharderBase64_initialize();
  IOSByteArray *raw3 = [IOSByteArray arrayWithLength:3];
  IOSByteArray *enc4 = [IOSByteArray arrayWithLength:4];
  while ([((JavaNioByteBuffer *) nil_chk(raw)) hasRemaining]) {
    jint rem = JavaLangMath_minWithInt_withInt_(3, [raw remaining]);
    [raw getWithByteArray:raw3 withInt:0 withInt:rem];
    NetIharderBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(enc4, raw3, rem, NetIharderBase64_NO_OPTIONS);
    [((JavaNioByteBuffer *) nil_chk(encoded)) putWithByteArray:enc4];
  }
}

void NetIharderBase64_encodeWithJavaNioByteBuffer_withJavaNioCharBuffer_(JavaNioByteBuffer *raw, JavaNioCharBuffer *encoded) {
  NetIharderBase64_initialize();
  IOSByteArray *raw3 = [IOSByteArray arrayWithLength:3];
  IOSByteArray *enc4 = [IOSByteArray arrayWithLength:4];
  while ([((JavaNioByteBuffer *) nil_chk(raw)) hasRemaining]) {
    jint rem = JavaLangMath_minWithInt_withInt_(3, [raw remaining]);
    [raw getWithByteArray:raw3 withInt:0 withInt:rem];
    NetIharderBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(enc4, raw3, rem, NetIharderBase64_NO_OPTIONS);
    for (jint i = 0; i < 4; i++) {
      [((JavaNioCharBuffer *) nil_chk(encoded)) putWithChar:(jchar) (IOSByteArray_Get(enc4, i) & (jint) 0xFF)];
    }
  }
}

NSString *NetIharderBase64_encodeObjectWithJavaIoSerializable_(id<JavaIoSerializable> serializableObject) {
  NetIharderBase64_initialize();
  return NetIharderBase64_encodeObjectWithJavaIoSerializable_withInt_(serializableObject, NetIharderBase64_NO_OPTIONS);
}

NSString *NetIharderBase64_encodeObjectWithJavaIoSerializable_withInt_(id<JavaIoSerializable> serializableObject, jint options) {
  NetIharderBase64_initialize();
  if (serializableObject == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"Cannot serialize a null object.");
  }
  JavaIoByteArrayOutputStream *baos = nil;
  JavaIoOutputStream *b64os = nil;
  JavaIoObjectOutputStream *oos = nil;
  @try {
    baos = create_JavaIoByteArrayOutputStream_init();
    b64os = create_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(baos, NetIharderBase64_ENCODE | options);
    oos = create_JavaIoObjectOutputStream_initWithJavaIoOutputStream_(b64os);
    [oos writeObjectWithId:serializableObject];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoObjectOutputStream *) nil_chk(oos)) close];
    }
    @catch (JavaLangException *e) {
    }
    @try {
      [((JavaIoOutputStream *) nil_chk(b64os)) close];
    }
    @catch (JavaLangException *e) {
    }
    @try {
      [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  @try {
    return [NSString java_stringWithBytes:[baos toByteArray] charsetName:NetIharderBase64_PREFERRED_ENCODING];
  }
  @catch (JavaIoUnsupportedEncodingException *uue) {
    return [NSString java_stringWithBytes:[baos toByteArray]];
  }
}

NSString *NetIharderBase64_encodeBytesWithByteArray_(IOSByteArray *source) {
  NetIharderBase64_initialize();
  NSString *encoded = nil;
  @try {
    encoded = NetIharderBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(source, 0, ((IOSByteArray *) nil_chk(source))->size_, NetIharderBase64_NO_OPTIONS);
  }
  @catch (JavaIoIOException *ex) {
    JreAssert(false, [ex getMessage]);
  }
  JreAssert(encoded != nil, @"net/iharder/Base64.java:696 condition failed: assert encoded != null;");
  return encoded;
}

NSString *NetIharderBase64_encodeBytesWithByteArray_withInt_(IOSByteArray *source, jint options) {
  NetIharderBase64_initialize();
  return NetIharderBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(source, 0, ((IOSByteArray *) nil_chk(source))->size_, options);
}

NSString *NetIharderBase64_encodeBytesWithByteArray_withInt_withInt_(IOSByteArray *source, jint off, jint len) {
  NetIharderBase64_initialize();
  NSString *encoded = nil;
  @try {
    encoded = NetIharderBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(source, off, len, NetIharderBase64_NO_OPTIONS);
  }
  @catch (JavaIoIOException *ex) {
    JreAssert(false, [ex getMessage]);
  }
  JreAssert(encoded != nil, @"net/iharder/Base64.java:764 condition failed: assert encoded != null;");
  return encoded;
}

NSString *NetIharderBase64_encodeBytesWithByteArray_withInt_withInt_withInt_(IOSByteArray *source, jint off, jint len, jint options) {
  NetIharderBase64_initialize();
  IOSByteArray *encoded = NetIharderBase64_encodeBytesToBytesWithByteArray_withInt_withInt_withInt_(source, off, len, options);
  @try {
    return [NSString java_stringWithBytes:encoded charsetName:NetIharderBase64_PREFERRED_ENCODING];
  }
  @catch (JavaIoUnsupportedEncodingException *uue) {
    return [NSString java_stringWithBytes:encoded];
  }
}

IOSByteArray *NetIharderBase64_encodeBytesToBytesWithByteArray_(IOSByteArray *source) {
  NetIharderBase64_initialize();
  IOSByteArray *encoded = nil;
  @try {
    encoded = NetIharderBase64_encodeBytesToBytesWithByteArray_withInt_withInt_withInt_(source, 0, ((IOSByteArray *) nil_chk(source))->size_, NetIharderBase64_NO_OPTIONS);
  }
  @catch (JavaIoIOException *ex) {
    JreAssert(false, JreStrcat("$$", @"IOExceptions only come from GZipping, which is turned off: ", [ex getMessage]));
  }
  return encoded;
}

IOSByteArray *NetIharderBase64_encodeBytesToBytesWithByteArray_withInt_withInt_withInt_(IOSByteArray *source, jint off, jint len, jint options) {
  NetIharderBase64_initialize();
  if (source == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"Cannot serialize a null array.");
  }
  if (off < 0) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Cannot have negative offset: ", off));
  }
  if (len < 0) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Cannot have length offset: ", len));
  }
  if (off + len > source->size_) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(NSString_java_formatWithNSString_withNSObjectArray_(@"Cannot have offset of %d and length of %d with array of length %d", [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(off), JavaLangInteger_valueOfWithInt_(len), JavaLangInteger_valueOfWithInt_(source->size_) } count:3 type:NSObject_class_()]));
  }
  if ((options & NetIharderBase64_GZIP) > 0) {
    JavaIoByteArrayOutputStream *baos = nil;
    JavaUtilZipGZIPOutputStream *gzos = nil;
    NetIharderBase64_OutputStream *b64os = nil;
    @try {
      baos = create_JavaIoByteArrayOutputStream_init();
      b64os = create_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(baos, NetIharderBase64_ENCODE | options);
      gzos = create_JavaUtilZipGZIPOutputStream_initWithJavaIoOutputStream_(b64os);
      [gzos writeWithByteArray:source withInt:off withInt:len];
      [gzos close];
    }
    @catch (JavaIoIOException *e) {
      @throw e;
    }
    @finally {
      @try {
        [((JavaUtilZipGZIPOutputStream *) nil_chk(gzos)) close];
      }
      @catch (JavaLangException *e) {
      }
      @try {
        [((NetIharderBase64_OutputStream *) nil_chk(b64os)) close];
      }
      @catch (JavaLangException *e) {
      }
      @try {
        [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
      }
      @catch (JavaLangException *e) {
      }
    }
    return [baos toByteArray];
  }
  else {
    jboolean breakLines = (options & NetIharderBase64_DO_BREAK_LINES) > 0;
    jint encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0);
    if (breakLines) {
      encLen += encLen / NetIharderBase64_MAX_LINE_LENGTH;
    }
    IOSByteArray *outBuff = [IOSByteArray arrayWithLength:encLen];
    jint d = 0;
    jint e = 0;
    jint len2 = len - 2;
    jint lineLength = 0;
    for (; d < len2; d += 3, e += 4) {
      NetIharderBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(source, d + off, 3, outBuff, e, options);
      lineLength += 4;
      if (breakLines && lineLength >= NetIharderBase64_MAX_LINE_LENGTH) {
        *IOSByteArray_GetRef(outBuff, e + 4) = NetIharderBase64_NEW_LINE;
        e++;
        lineLength = 0;
      }
    }
    if (d < len) {
      NetIharderBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(source, d + off, len - d, outBuff, e, options);
      e += 4;
    }
    if (e < outBuff->size_ - 1) {
      IOSByteArray *finalOut = [IOSByteArray arrayWithLength:e];
      JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(outBuff, 0, finalOut, 0, e);
      return finalOut;
    }
    else {
      return outBuff;
    }
  }
}

jint NetIharderBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(IOSByteArray *source, jint srcOffset, IOSByteArray *destination, jint destOffset, jint options) {
  NetIharderBase64_initialize();
  if (source == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"Source array was null.");
  }
  if (destination == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"Destination array was null.");
  }
  if (srcOffset < 0 || srcOffset + 3 >= source->size_) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(NSString_java_formatWithNSString_withNSObjectArray_(@"Source array with length %d cannot have offset of %d and still process four bytes.", [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(source->size_), JavaLangInteger_valueOfWithInt_(srcOffset) } count:2 type:NSObject_class_()]));
  }
  if (destOffset < 0 || destOffset + 2 >= destination->size_) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(NSString_java_formatWithNSString_withNSObjectArray_(@"Destination array with length %d cannot have offset of %d and still store three bytes.", [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(destination->size_), JavaLangInteger_valueOfWithInt_(destOffset) } count:2 type:NSObject_class_()]));
  }
  IOSByteArray *DECODABET = NetIharderBase64_getDecodabetWithInt_(options);
  if (IOSByteArray_Get(source, srcOffset + 2) == NetIharderBase64_EQUALS_SIGN) {
    jint outBuff = (JreLShift32((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (jint) 0xFF), 18)) | (JreLShift32((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (jint) 0xFF), 12));
    *IOSByteArray_GetRef(destination, destOffset) = (jbyte) (JreURShift32(outBuff, 16));
    return 1;
  }
  else if (IOSByteArray_Get(source, srcOffset + 3) == NetIharderBase64_EQUALS_SIGN) {
    jint outBuff = (JreLShift32((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (jint) 0xFF), 18)) | (JreLShift32((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (jint) 0xFF), 12)) | (JreLShift32((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 2)) & (jint) 0xFF), 6));
    *IOSByteArray_GetRef(destination, destOffset) = (jbyte) (JreURShift32(outBuff, 16));
    *IOSByteArray_GetRef(destination, destOffset + 1) = (jbyte) (JreURShift32(outBuff, 8));
    return 2;
  }
  else {
    jint outBuff = (JreLShift32((IOSByteArray_Get(nil_chk(DECODABET), IOSByteArray_Get(source, srcOffset)) & (jint) 0xFF), 18)) | (JreLShift32((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 1)) & (jint) 0xFF), 12)) | (JreLShift32((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 2)) & (jint) 0xFF), 6)) | ((IOSByteArray_Get(DECODABET, IOSByteArray_Get(source, srcOffset + 3)) & (jint) 0xFF));
    *IOSByteArray_GetRef(destination, destOffset) = (jbyte) (JreRShift32(outBuff, 16));
    *IOSByteArray_GetRef(destination, destOffset + 1) = (jbyte) (JreRShift32(outBuff, 8));
    *IOSByteArray_GetRef(destination, destOffset + 2) = (jbyte) (outBuff);
    return 3;
  }
}

IOSByteArray *NetIharderBase64_decodeWithByteArray_(IOSByteArray *source) {
  NetIharderBase64_initialize();
  IOSByteArray *decoded = nil;
  @try {
    decoded = NetIharderBase64_decodeWithByteArray_withInt_withInt_withInt_(source, 0, ((IOSByteArray *) nil_chk(source))->size_, NetIharderBase64_NO_OPTIONS);
  }
  @catch (JavaIoIOException *ex) {
    JreAssert(false, JreStrcat("$$", @"IOExceptions only come from GZipping, which is turned off: ", [ex getMessage]));
  }
  return decoded;
}

IOSByteArray *NetIharderBase64_decodeWithByteArray_withInt_withInt_withInt_(IOSByteArray *source, jint off, jint len, jint options) {
  NetIharderBase64_initialize();
  if (source == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"Cannot decode null source array.");
  }
  if (off < 0 || off + len > source->size_) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(NSString_java_formatWithNSString_withNSObjectArray_(@"Source array with length %d cannot have offset of %d and process %d bytes.", [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(source->size_), JavaLangInteger_valueOfWithInt_(off), JavaLangInteger_valueOfWithInt_(len) } count:3 type:NSObject_class_()]));
  }
  if (len == 0) {
    return [IOSByteArray arrayWithLength:0];
  }
  else if (len < 4) {
    @throw create_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Base64-encoded string must have at least four characters, but length specified was ", len));
  }
  IOSByteArray *DECODABET = NetIharderBase64_getDecodabetWithInt_(options);
  jint len34 = len * 3 / 4;
  IOSByteArray *outBuff = [IOSByteArray arrayWithLength:len34];
  jint outBuffPosn = 0;
  IOSByteArray *b4 = [IOSByteArray arrayWithLength:4];
  jint b4Posn = 0;
  jint i = 0;
  jbyte sbiCrop = 0;
  jbyte sbiDecode = 0;
  for (i = off; i < off + len; i++) {
    sbiCrop = (jbyte) (IOSByteArray_Get(source, i) & (jint) 0x7f);
    sbiDecode = IOSByteArray_Get(nil_chk(DECODABET), sbiCrop);
    if (sbiDecode >= NetIharderBase64_WHITE_SPACE_ENC) {
      if (sbiDecode >= NetIharderBase64_EQUALS_SIGN_ENC) {
        *IOSByteArray_GetRef(b4, b4Posn++) = sbiCrop;
        if (b4Posn > 3) {
          outBuffPosn += NetIharderBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(b4, 0, outBuff, outBuffPosn, options);
          b4Posn = 0;
          if (sbiCrop == NetIharderBase64_EQUALS_SIGN) {
            break;
          }
        }
      }
    }
    else {
      @throw create_JavaIoIOException_initWithNSString_(NSString_java_formatWithNSString_withNSObjectArray_(@"Bad Base64 input character '%c' in array position %d", [IOSObjectArray arrayWithObjects:(id[]){ JavaLangByte_valueOfWithByte_(IOSByteArray_Get(source, i)), JavaLangInteger_valueOfWithInt_(i) } count:2 type:NSObject_class_()]));
    }
  }
  IOSByteArray *out = [IOSByteArray arrayWithLength:outBuffPosn];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(outBuff, 0, out, 0, outBuffPosn);
  return out;
}

IOSByteArray *NetIharderBase64_decodeWithNSString_(NSString *s) {
  NetIharderBase64_initialize();
  return NetIharderBase64_decodeWithNSString_withInt_(s, NetIharderBase64_NO_OPTIONS);
}

IOSByteArray *NetIharderBase64_decodeWithNSString_withInt_(NSString *s, jint options) {
  NetIharderBase64_initialize();
  if (s == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"Input string was null.");
  }
  IOSByteArray *bytes;
  @try {
    bytes = [s java_getBytesWithCharsetName:NetIharderBase64_PREFERRED_ENCODING];
  }
  @catch (JavaIoUnsupportedEncodingException *uee) {
    bytes = [s java_getBytes];
  }
  bytes = NetIharderBase64_decodeWithByteArray_withInt_withInt_withInt_(bytes, 0, ((IOSByteArray *) nil_chk(bytes))->size_, options);
  if (bytes != nil && bytes->size_ >= 4) {
    jint head = ((jint) IOSByteArray_Get(bytes, 0) & (jint) 0xff) | ((JreLShift32(IOSByteArray_Get(bytes, 1), 8)) & (jint) 0xff00);
    if (JavaUtilZipGZIPInputStream_GZIP_MAGIC == head) {
      JavaIoByteArrayInputStream *bais = nil;
      JavaUtilZipGZIPInputStream *gzis = nil;
      JavaIoByteArrayOutputStream *baos = nil;
      IOSByteArray *buffer = [IOSByteArray arrayWithLength:2048];
      jint length = 0;
      @try {
        baos = create_JavaIoByteArrayOutputStream_init();
        bais = create_JavaIoByteArrayInputStream_initWithByteArray_(bytes);
        gzis = create_JavaUtilZipGZIPInputStream_initWithJavaIoInputStream_(bais);
        while ((length = [gzis readWithByteArray:buffer]) >= 0) {
          [baos writeWithByteArray:buffer withInt:0 withInt:length];
        }
        bytes = [baos toByteArray];
      }
      @catch (JavaIoIOException *e) {
      }
      @finally {
        @try {
          [((JavaIoByteArrayOutputStream *) nil_chk(baos)) close];
        }
        @catch (JavaLangException *e) {
        }
        @try {
          [((JavaUtilZipGZIPInputStream *) nil_chk(gzis)) close];
        }
        @catch (JavaLangException *e) {
        }
        @try {
          [((JavaIoByteArrayInputStream *) nil_chk(bais)) close];
        }
        @catch (JavaLangException *e) {
        }
      }
    }
  }
  return bytes;
}

id NetIharderBase64_decodeToObjectWithNSString_(NSString *encodedObject) {
  NetIharderBase64_initialize();
  IOSByteArray *objBytes = NetIharderBase64_decodeWithNSString_(encodedObject);
  JavaIoByteArrayInputStream *bais = nil;
  JavaIoObjectInputStream *ois = nil;
  id obj = nil;
  @try {
    bais = create_JavaIoByteArrayInputStream_initWithByteArray_(objBytes);
    ois = create_JavaIoObjectInputStream_initWithJavaIoInputStream_(bais);
    obj = [ois readObject];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @catch (JavaLangClassNotFoundException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoByteArrayInputStream *) nil_chk(bais)) close];
    }
    @catch (JavaLangException *e) {
    }
    @try {
      [((JavaIoObjectInputStream *) nil_chk(ois)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  return obj;
}

void NetIharderBase64_encodeToFileWithByteArray_withNSString_(IOSByteArray *dataToEncode, NSString *filename) {
  NetIharderBase64_initialize();
  if (dataToEncode == nil) {
    @throw create_JavaLangNullPointerException_initWithNSString_(@"Data to encode was null.");
  }
  NetIharderBase64_OutputStream *bos = nil;
  @try {
    bos = create_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(create_JavaIoFileOutputStream_initWithNSString_(filename), NetIharderBase64_ENCODE);
    [bos writeWithByteArray:dataToEncode];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((NetIharderBase64_OutputStream *) nil_chk(bos)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
}

void NetIharderBase64_decodeToFileWithNSString_withNSString_(NSString *dataToDecode, NSString *filename) {
  NetIharderBase64_initialize();
  NetIharderBase64_OutputStream *bos = nil;
  @try {
    bos = create_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(create_JavaIoFileOutputStream_initWithNSString_(filename), NetIharderBase64_DECODE);
    [bos writeWithByteArray:[((NSString *) nil_chk(dataToDecode)) java_getBytesWithCharsetName:NetIharderBase64_PREFERRED_ENCODING]];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((NetIharderBase64_OutputStream *) nil_chk(bos)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
}

IOSByteArray *NetIharderBase64_decodeFromFileWithNSString_(NSString *filename) {
  NetIharderBase64_initialize();
  IOSByteArray *decodedData = nil;
  NetIharderBase64_InputStream *bis = nil;
  @try {
    JavaIoFile *file = create_JavaIoFile_initWithNSString_(filename);
    IOSByteArray *buffer = nil;
    jint length = 0;
    jint numBytes = 0;
    if ([file length] > JavaLangInteger_MAX_VALUE) {
      @throw create_JavaIoIOException_initWithNSString_(JreStrcat("$J$", @"File is too big for this convenience method (", [file length], @" bytes)."));
    }
    buffer = [IOSByteArray arrayWithLength:(jint) [file length]];
    bis = create_NetIharderBase64_InputStream_initWithJavaIoInputStream_withInt_(create_JavaIoBufferedInputStream_initWithJavaIoInputStream_(create_JavaIoFileInputStream_initWithJavaIoFile_(file)), NetIharderBase64_DECODE);
    while ((numBytes = [bis readWithByteArray:buffer withInt:length withInt:4096]) >= 0) {
      length += numBytes;
    }
    decodedData = [IOSByteArray arrayWithLength:length];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(buffer, 0, decodedData, 0, length);
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((NetIharderBase64_InputStream *) nil_chk(bis)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  return decodedData;
}

NSString *NetIharderBase64_encodeFromFileWithNSString_(NSString *filename) {
  NetIharderBase64_initialize();
  NSString *encodedData = nil;
  NetIharderBase64_InputStream *bis = nil;
  @try {
    JavaIoFile *file = create_JavaIoFile_initWithNSString_(filename);
    IOSByteArray *buffer = [IOSByteArray arrayWithLength:JavaLangMath_maxWithInt_withInt_(JreFpToInt(([file length] * 1.4)), 40)];
    jint length = 0;
    jint numBytes = 0;
    bis = create_NetIharderBase64_InputStream_initWithJavaIoInputStream_withInt_(create_JavaIoBufferedInputStream_initWithJavaIoInputStream_(create_JavaIoFileInputStream_initWithJavaIoFile_(file)), NetIharderBase64_ENCODE);
    while ((numBytes = [bis readWithByteArray:buffer withInt:length withInt:4096]) >= 0) {
      length += numBytes;
    }
    encodedData = [NSString java_stringWithBytes:buffer offset:0 length:length charsetName:NetIharderBase64_PREFERRED_ENCODING];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((NetIharderBase64_InputStream *) nil_chk(bis)) close];
    }
    @catch (JavaLangException *e) {
    }
  }
  return encodedData;
}

void NetIharderBase64_encodeFileToFileWithNSString_withNSString_(NSString *infile, NSString *outfile) {
  NetIharderBase64_initialize();
  NSString *encoded = NetIharderBase64_encodeFromFileWithNSString_(infile);
  JavaIoOutputStream *out = nil;
  @try {
    out = create_JavaIoBufferedOutputStream_initWithJavaIoOutputStream_(create_JavaIoFileOutputStream_initWithNSString_(outfile));
    [out writeWithByteArray:[((NSString *) nil_chk(encoded)) java_getBytesWithCharsetName:@"US-ASCII"]];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoOutputStream *) nil_chk(out)) close];
    }
    @catch (JavaLangException *ex) {
    }
  }
}

void NetIharderBase64_decodeFileToFileWithNSString_withNSString_(NSString *infile, NSString *outfile) {
  NetIharderBase64_initialize();
  IOSByteArray *decoded = NetIharderBase64_decodeFromFileWithNSString_(infile);
  JavaIoOutputStream *out = nil;
  @try {
    out = create_JavaIoBufferedOutputStream_initWithJavaIoOutputStream_(create_JavaIoFileOutputStream_initWithNSString_(outfile));
    [out writeWithByteArray:decoded];
  }
  @catch (JavaIoIOException *e) {
    @throw e;
  }
  @finally {
    @try {
      [((JavaIoOutputStream *) nil_chk(out)) close];
    }
    @catch (JavaLangException *ex) {
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetIharderBase64)

@implementation NetIharderBase64_InputStream

- (instancetype __nonnull)initWithJavaIoInputStream:(JavaIoInputStream *)inArg {
  NetIharderBase64_InputStream_initWithJavaIoInputStream_(self, inArg);
  return self;
}

- (instancetype __nonnull)initWithJavaIoInputStream:(JavaIoInputStream *)inArg
                                            withInt:(jint)options {
  NetIharderBase64_InputStream_initWithJavaIoInputStream_withInt_(self, inArg, options);
  return self;
}

- (jint)read {
  if (position_ < 0) {
    if (encode_) {
      IOSByteArray *b3 = [IOSByteArray arrayWithLength:3];
      jint numBinaryBytes = 0;
      for (jint i = 0; i < 3; i++) {
        jint b = [((JavaIoInputStream *) nil_chk(JreLoadVolatileId(&in_))) read];
        if (b >= 0) {
          *IOSByteArray_GetRef(b3, i) = (jbyte) b;
          numBinaryBytes++;
        }
        else {
          break;
        }
      }
      if (numBinaryBytes > 0) {
        NetIharderBase64_encode3to4WithByteArray_withInt_withInt_withByteArray_withInt_withInt_(b3, 0, numBinaryBytes, buffer_, 0, options_);
        position_ = 0;
        numSigBytes_ = 4;
      }
      else {
        return -1;
      }
    }
    else {
      IOSByteArray *b4 = [IOSByteArray arrayWithLength:4];
      jint i = 0;
      for (i = 0; i < 4; i++) {
        jint b = 0;
        do {
          b = [((JavaIoInputStream *) nil_chk(JreLoadVolatileId(&in_))) read];
        }
        while (b >= 0 && IOSByteArray_Get(nil_chk(decodabet_), b & (jint) 0x7f) <= NetIharderBase64_WHITE_SPACE_ENC);
        if (b < 0) {
          break;
        }
        *IOSByteArray_GetRef(b4, i) = (jbyte) b;
      }
      if (i == 4) {
        numSigBytes_ = NetIharderBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(b4, 0, buffer_, 0, options_);
        position_ = 0;
      }
      else if (i == 0) {
        return -1;
      }
      else {
        @throw create_JavaIoIOException_initWithNSString_(@"Improperly padded Base64 input.");
      }
    }
  }
  if (position_ >= 0) {
    if (position_ >= numSigBytes_) {
      return -1;
    }
    if (encode_ && breakLines_ && lineLength_ >= NetIharderBase64_MAX_LINE_LENGTH) {
      lineLength_ = 0;
      return 0x000a;
    }
    else {
      lineLength_++;
      jint b = IOSByteArray_Get(nil_chk(buffer_), position_++);
      if (position_ >= bufferLength_) {
        position_ = -1;
      }
      return b & (jint) 0xFF;
    }
  }
  else {
    @throw create_JavaIoIOException_initWithNSString_(@"Error in Base64 code reading stream.");
  }
}

- (jint)readWithByteArray:(IOSByteArray *)dest
                  withInt:(jint)off
                  withInt:(jint)len {
  jint i;
  jint b;
  for (i = 0; i < len; i++) {
    b = [self read];
    if (b >= 0) {
      *IOSByteArray_GetRef(nil_chk(dest), off + i) = (jbyte) b;
    }
    else if (i == 0) {
      return -1;
    }
    else {
      break;
    }
  }
  return i;
}

- (void)dealloc {
  RELEASE_(buffer_);
  RELEASE_(alphabet_);
  RELEASE_(decodabet_);
  [super dealloc];
}

@end

void NetIharderBase64_InputStream_initWithJavaIoInputStream_(NetIharderBase64_InputStream *self, JavaIoInputStream *inArg) {
  NetIharderBase64_InputStream_initWithJavaIoInputStream_withInt_(self, inArg, NetIharderBase64_DECODE);
}

NetIharderBase64_InputStream *new_NetIharderBase64_InputStream_initWithJavaIoInputStream_(JavaIoInputStream *inArg) {
  J2OBJC_NEW_IMPL(NetIharderBase64_InputStream, initWithJavaIoInputStream_, inArg)
}

NetIharderBase64_InputStream *create_NetIharderBase64_InputStream_initWithJavaIoInputStream_(JavaIoInputStream *inArg) {
  J2OBJC_CREATE_IMPL(NetIharderBase64_InputStream, initWithJavaIoInputStream_, inArg)
}

void NetIharderBase64_InputStream_initWithJavaIoInputStream_withInt_(NetIharderBase64_InputStream *self, JavaIoInputStream *inArg, jint options) {
  JavaIoFilterInputStream_initWithJavaIoInputStream_(self, inArg);
  self->options_ = options;
  self->breakLines_ = ((options & NetIharderBase64_DO_BREAK_LINES) > 0);
  self->encode_ = ((options & NetIharderBase64_ENCODE) > 0);
  self->bufferLength_ = self->encode_ ? 4 : 3;
  JreStrongAssignAndConsume(&self->buffer_, [IOSByteArray newArrayWithLength:self->bufferLength_]);
  self->position_ = -1;
  self->lineLength_ = 0;
  JreStrongAssign(&self->alphabet_, NetIharderBase64_getAlphabetWithInt_(options));
  JreStrongAssign(&self->decodabet_, NetIharderBase64_getDecodabetWithInt_(options));
}

NetIharderBase64_InputStream *new_NetIharderBase64_InputStream_initWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint options) {
  J2OBJC_NEW_IMPL(NetIharderBase64_InputStream, initWithJavaIoInputStream_withInt_, inArg, options)
}

NetIharderBase64_InputStream *create_NetIharderBase64_InputStream_initWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint options) {
  J2OBJC_CREATE_IMPL(NetIharderBase64_InputStream, initWithJavaIoInputStream_withInt_, inArg, options)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetIharderBase64_InputStream)

@implementation NetIharderBase64_OutputStream

- (instancetype __nonnull)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg {
  NetIharderBase64_OutputStream_initWithJavaIoOutputStream_(self, outArg);
  return self;
}

- (instancetype __nonnull)initWithJavaIoOutputStream:(JavaIoOutputStream *)outArg
                                             withInt:(jint)options {
  NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(self, outArg, options);
  return self;
}

- (void)writeWithInt:(jint)theByte {
  if (suspendEncoding_) {
    [((JavaIoOutputStream *) nil_chk(out_)) writeWithInt:theByte];
    return;
  }
  if (encode_) {
    *IOSByteArray_GetRef(nil_chk(buffer_), position_++) = (jbyte) theByte;
    if (position_ >= bufferLength_) {
      [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:NetIharderBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(b4_, buffer_, bufferLength_, options_)];
      lineLength_ += 4;
      if (breakLines_ && lineLength_ >= NetIharderBase64_MAX_LINE_LENGTH) {
        [((JavaIoOutputStream *) nil_chk(out_)) writeWithInt:NetIharderBase64_NEW_LINE];
        lineLength_ = 0;
      }
      position_ = 0;
    }
  }
  else {
    if (IOSByteArray_Get(nil_chk(decodabet_), theByte & (jint) 0x7f) > NetIharderBase64_WHITE_SPACE_ENC) {
      *IOSByteArray_GetRef(nil_chk(buffer_), position_++) = (jbyte) theByte;
      if (position_ >= bufferLength_) {
        jint len = NetIharderBase64_decode4to3WithByteArray_withInt_withByteArray_withInt_withInt_(buffer_, 0, b4_, 0, options_);
        [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:b4_ withInt:0 withInt:len];
        position_ = 0;
      }
    }
    else if (IOSByteArray_Get(decodabet_, theByte & (jint) 0x7f) != NetIharderBase64_WHITE_SPACE_ENC) {
      @throw create_JavaIoIOException_initWithNSString_(@"Invalid character in Base64 data.");
    }
  }
}

- (void)writeWithByteArray:(IOSByteArray *)theBytes
                   withInt:(jint)off
                   withInt:(jint)len {
  if (suspendEncoding_) {
    [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:theBytes withInt:off withInt:len];
    return;
  }
  for (jint i = 0; i < len; i++) {
    [self writeWithInt:IOSByteArray_Get(nil_chk(theBytes), off + i)];
  }
}

- (void)flushBase64 {
  if (position_ > 0) {
    if (encode_) {
      [((JavaIoOutputStream *) nil_chk(out_)) writeWithByteArray:NetIharderBase64_encode3to4WithByteArray_withByteArray_withInt_withInt_(b4_, buffer_, position_, options_)];
      position_ = 0;
    }
    else {
      @throw create_JavaIoIOException_initWithNSString_(@"Base64 input not properly padded.");
    }
  }
}

- (void)flush {
  [self flushBase64];
  [super flush];
}

- (void)close {
  [self flush];
  [super close];
  JreStrongAssign(&buffer_, nil);
  JreStrongAssign(&out_, nil);
}

- (void)suspendEncoding {
  [self flushBase64];
  self->suspendEncoding_ = true;
}

- (void)resumeEncoding {
  self->suspendEncoding_ = false;
}

- (void)dealloc {
  RELEASE_(buffer_);
  RELEASE_(b4_);
  RELEASE_(alphabet_);
  RELEASE_(decodabet_);
  [super dealloc];
}

@end

void NetIharderBase64_OutputStream_initWithJavaIoOutputStream_(NetIharderBase64_OutputStream *self, JavaIoOutputStream *outArg) {
  NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(self, outArg, NetIharderBase64_ENCODE);
}

NetIharderBase64_OutputStream *new_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_(JavaIoOutputStream *outArg) {
  J2OBJC_NEW_IMPL(NetIharderBase64_OutputStream, initWithJavaIoOutputStream_, outArg)
}

NetIharderBase64_OutputStream *create_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_(JavaIoOutputStream *outArg) {
  J2OBJC_CREATE_IMPL(NetIharderBase64_OutputStream, initWithJavaIoOutputStream_, outArg)
}

void NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(NetIharderBase64_OutputStream *self, JavaIoOutputStream *outArg, jint options) {
  JavaIoFilterOutputStream_initWithJavaIoOutputStream_(self, outArg);
  self->breakLines_ = ((options & NetIharderBase64_DO_BREAK_LINES) > 0);
  self->encode_ = ((options & NetIharderBase64_ENCODE) > 0);
  self->bufferLength_ = self->encode_ ? 3 : 4;
  JreStrongAssignAndConsume(&self->buffer_, [IOSByteArray newArrayWithLength:self->bufferLength_]);
  self->position_ = 0;
  self->lineLength_ = 0;
  self->suspendEncoding_ = false;
  JreStrongAssignAndConsume(&self->b4_, [IOSByteArray newArrayWithLength:4]);
  self->options_ = options;
  JreStrongAssign(&self->alphabet_, NetIharderBase64_getAlphabetWithInt_(options));
  JreStrongAssign(&self->decodabet_, NetIharderBase64_getDecodabetWithInt_(options));
}

NetIharderBase64_OutputStream *new_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(JavaIoOutputStream *outArg, jint options) {
  J2OBJC_NEW_IMPL(NetIharderBase64_OutputStream, initWithJavaIoOutputStream_withInt_, outArg, options)
}

NetIharderBase64_OutputStream *create_NetIharderBase64_OutputStream_initWithJavaIoOutputStream_withInt_(JavaIoOutputStream *outArg, jint options) {
  J2OBJC_CREATE_IMPL(NetIharderBase64_OutputStream, initWithJavaIoOutputStream_withInt_, outArg, options)
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(NetIharderBase64_OutputStream)
